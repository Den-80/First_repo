""" ***************************************** """
    # Робота з файлами та обробка виключень #
""" ***************************************** """

""" ------------------- """
    # Робота з файлами
""" ------------------- """
"""
У Python є абстракція над файлами — це вказівник на файл або файловий об'єкт. 
Нічого складного в цьому немає, це навпаки спрощує роботу з багатьма системними ресурсами.

Файловий об'єкт — це системний ресурс, доступ до якого надає операційна система. 
Зазвичай файловий об'єкт можна відкрити (отримати/створити), закрити (повідомити системі, що робота з ним завершена), можна записати у нього щось і прочитати щось.

Безпосередня робота з файлами у Python починається з відкриття файлу або отримання від системи доступу до файлу, 
отримання того самого файлового об'єкту. 
Для цього є вбудована функція open, в яку потрібно обов'язково передати ім'я файлу, який ми хочемо відкрити, 
і можна вказати, як саме ми хочемо відкрити файл:

fh = open('test_file.txt')

В цьому прикладі fh — це файловий об'єкт, через який ми можемо працювати з файлом.

Після того, як робота з файлом завершена, потрібно повернути ресурс (файл) системі. 
Для цього у файлового об'єкта потрібно викликати метод close:

fh = open('test.txt')
# операції над файлом
fh.close()

Закривати файл обов'язково. Незакриті файли можуть стати причиною безлічі неочевидних проблем і складнощів. 
Найпростіший випадок — це зіпсований файл і повністю втрачена інформація, яка в ньому могла міститися.

Якщо не вказати, як ми хочемо відкрити файл, то він відкривається тільки для зчитування даних і за допомогою fh можна буде тільки читати дані з файлу. 
Якщо файлу з ім'ям test_file.txt в системі немає, то ви отримаєте виняток.
"""

# Функція open() повертає файловий об'єкт, який далі може бути використаний для читання з файлу або запису в нього.
open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)
"""
Параметри:

* file - шлях до файлу у вигляді рядка. Це може бути повний шлях або шлях відносно поточного каталогу виконання.
* mode (необов'язковий) - режим, в якому буде відкрито файл. Ось основні режими які ми будемо використовувати:
    * 'r' - читання (за замовчуванням). Файл має існувати.
    * 'w' - запис. Створює новий файл або перезаписує, що вже існує.
    * 'a' - додавання. Дописує в кінець файлу, не перезаписуючи його.
    * 'b' - бінарний режим (може бути використаний разом з іншими, наприклад 'rb' або 'wb').
    * '+' - оновлення (читання та запис).
* buffering (необов'язковий) - визначає буферизацію: 0 для вимкненої, 1 для включеної буферизації рядків, більше 1 для вказання розміру буфера у байтах.
* encoding (необов'язковий) - ім'я кодування, яке буде використовуватися для кодування або декодування файлу.
* errors (необов'язковий) - вказує, як обробляти помилки кодування.
* newline (необов'язковий) - контролює, як обробляються нові рядки.
* closefd (необов'язковий) - має бути True (за замовчуванням); якщо вказано False, файловий дескриптор не буде закритий.
* opener (необов'язковий) - визначає спеціальну функцію для відкриття файлу.
"""

# Наприклад, щоб відкрити файл для запису або створити новий, якщо його немає, або перезаписати файл, можна вказати значення режиму w:
fh = open('test.txt', 'w')
symbols_written = fh.write('hello!')
print(symbols_written) # 6
fh.close()
"""
В цьому прикладі ми створили (або перезаписали, якщо він вже існував) файл test.txt для запису та записали туди рядок 'hello!' завдовжки 6 символів. 
Для запису даних у файл ми використали метод write у об'єкта fh. Цей метод повертає кількість записаних у файл символів - в нашому випадку число 6.
"""

# Парний до нього метод — це метод read, який дозволяє прочитати деяку кількість символів із файлу.
fh = open('test.txt', 'w+')
fh.write('hello!')
fh.seek(0)

first_two_symbols = fh.read(2)
print(first_two_symbols)  # 'he'

fh.close()
"""
В цьому прикладі ми відкрили файл в режимі для читання та запису, але сам файл ми перезаписуємо, якщо він існує, 
бо використовується режим w+. 
Записали у файл рядок 'hello!' та прочитали перші два символи із файлу за допомогою методу read, вказавши у якості аргументу двійку. 
Метод read повертає прочитанні символи і оскільки ми прочитали 2 символи, то змінна first_two_symbols буде зберігати рядок "he". 
Для того, щоб повернути вказівник на початок файлу ми викликали метод seek та передали йому позицію, куди потрібно переміститися 0. 
"""
# Щоб прочитати увесь вміст файлу за раз, можна викликати метод read без аргументів:
fh = open('test.txt', 'w')
fh.write('hello!')
fh.close()

fh = open('test.txt', 'r')
all_file = fh.read()
print(all_file)  # 'hello!'

fh.close()

# Доки файловий дескриптор не закритий, ви можете читати із нього частинами, продовжуючи читання з того самого місця, на якому зупинилися:
fh = open('test.txt', 'w')
fh.write('hello!')
fh.close()

fh = open('test.txt', 'r')
while True:
    symbol = fh.read(1)
    if len(symbol) == 0:
        break
    print(symbol)

fh.close()

# Ще є зручний спосіб читати файл порядково, по одному рядку за раз, для цього можна скористатися методом readline:
fh = open('test.txt', 'w')
fh.write('first line\nsecond line\nthird line')
fh.close()

fh = open('test.txt', 'r')
while True:
    line = fh.readline()
    if not line:
        break
    print(line)

fh.close()

# Та аналогічний метод readlines, який читає увесь файл повністю, але повертає список рядків, де елемент списку — це один рядок з файлу.
fh = open('test.txt', 'w')
fh.write('first line\nsecond line\nthird line')
fh.close()

fh = open('test.txt', 'r')
lines = fh.readlines()
print(lines)

fh.close()

"""
Тепер повернемось до детального розгляду метода seek. 
Python дає можливість управляти положенням курсора (вказівника) у файлі та довільно переміщатися файлом за допомогою методу seek. 
Цей метод приймає один аргумент — це кількість символів, на які потрібно змістити курсор у файлі:
"""
fh = open('test.txt', 'w+')
fh.write('hello!')

fh.seek(1)
second = fh.read(1)
print(second)  # 'e'

fh.close()
# В цьому прикладі після запису у файл курсор буде зупинений на останньому символі. У виразі fh.seek(1) ми перемістили курсор на другий символ у файлі. 
# Переміщаючи курсор, можна перезаписувати символи файлу або читати записане.

"""
Щоб дізнатися положення курсора в цей момент, можна скористатися методом tell, 
він повертає позицію (номер) символу з початку файлу, де зараз знаходиться курсор.
"""
fh = open("test.txt", "w+")
fh.write("hello!")

position = fh.tell()
print(position)  # 6

fh.seek(1)
position = fh.tell()
print(position)  # 1

fh.read(2)
position = fh.tell()
print(position)  # 3

fh.close()


""" ------------------- """
    # Менеджер контексту
""" ------------------- """
"""
Застосунок може виконати багато операцій між відкриттям та закриттям файлу. 
В будь-якому місці може статися помилка та застосунок завершиться аварійно, не повернувши файловий дескриптор системі. 
Така поведінка, як вже згадувалося, небажана і може призводити до втрати даних.
Щоб уникнути цього, можна взяти блок коду, в якому відбувається робота з файлом, у блок try ... except:
"""
fh = open('text.txt', 'w')
try:
    # Виконання операцій з файлом
    fh.write('Some data')
finally:
    # Закриття файлу в блоку finally гарантує, що файл закриється навіть у разі помилки
    fh.close()
"""
Цей підхід гарантує, що файл закриється, але код виглядає трохи загромадженим. 
Якщо станеться виняток, то обов'язково виконається блок finally, в якому файл буде закритий. 
Такий підхід гарантує, що файловий дескриптор буде обов'язково повернений системі. 
Але такий підхід не надто елегантний та читабельний.
"""

# ☝ Використання конструкції with є кращою практикою, оскільки вона гарантує, що файл буде належним чином закритий після завершення блоку коду.
"""
Для покращення читабельності коду при збереженні функціоналу можна скористатися менеджером контексту with. 
Менеджер контексту в Python - це спосіб використання ресурсів, який автоматично забезпечує правильне закриття файлу, незалежно від того, чи виникла помилка чи ні. 
Це робить код не тільки більш читабельним, але й безпечнішим.
"""
with open('text.txt', 'w') as fh:
    # Виконання операцій з файлом
    fh.write('Some data')
# Файл автоматично закриється після виходу з блоку with
"""
Менеджер контексту складається з ключового слова with, після якого викликається сам менеджер і, 
якщо щось потрібно повернути з менеджера, то це щось можна передати у змінну, оголошену після ключового слова as. 
Далі ставиться двокрапка і блок коду, який буде виконаний всередині менеджера. 
У прикладі з try ... finally — це код, який йде всередині блоку try. 
Коли код виконається, менеджер контексту виконає те, що повинен зробити в будь-якому випадку, закрити файл, наприклад (це те, що відбувається в блоку finally).

Менеджер контексту open синтаксично повністю повторює свого класичного тезку open, вони повністю ідентичні з точки зору використання.

З точки зору роботи, цей приклад робить у точності те саме, що і попередній з блоком try ... finally. 
Але замість п'яти рядків коду, ви можете написати два, і код виглядає читабельнішим. 
Тут with автоматично забезпечує закриття файлу, навіть якщо виникає помилка всередині блоку коду. 
Це робить код не тільки чистішим, але й безпечнішим, оскільки знижує ризик забути закрити файл.

Такий спосіб роботи з файлами є рекомендованим у Python, оскільки гарантує, що програміст не забуде закрити файл у будь-якому разі.
"""
with open("test.txt", "w") as fh:
    fh.write("first line\nsecond line\nthird line")

with open("test.txt", "r") as fh:
    lines = [el.strip() for el in fh.readlines()]

print(lines)

""" ------------------------------------------ """
    # Робота з не текстовими файлами у Python
""" ----------------------------------------- """
"""
Поки що ми розглядали тільки роботу з текстовими фалами в кодуванні UTF-8. 
Це режим роботи з файлами за замовчуванням. 
Якщо ж потрібно працювати не з текстовими файлами, то можна вказати режим відкриття файлів як b, скорочено від bytes. 
У такому режимі ви отримаєте файловий об'єкт для роботи з файлом в режимі байт-рядків.
"""
with open('raw_data.bin', 'wb') as fh:
    fh.write(b'Hello world!')

"""
В цьому прикладі ми відкрили файл raw_data.bin у режимі для запису "сирих" даних, на що вказує значення wb. 
В цьому режимі у файл можна писати тільки байт-рядки або байт-масиви.

У режимі роботи з "сирими" даними можна відкрити та прочитати вміст будь-якого файлу. 
Замість терміну “сирі” дані, можуть також казати двійкові дані або бінарні дані.

Отже є ще один контейнер, з яким ми раніше не працювали. Це bytes — байтові рядки.
Байтові рядки в Python є важливим інструментом для роботи з двійковими даними. 
Вони дозволяють зберігати та обробляти байти, які є основними будівельними блоками даних у комп'ютерах.

У пам'яті комп'ютера дані зберігаються як послідовності байтів. 
Будь-яка інформація - текст, зображення, звук, тощо - може бути представлена у вигляді байтів. 
ідповідно, будь-які дані можна представити у вигляді послідовності байтів.

Щоб працювати з послідовністю байтів у Python є вбудовані типи даних байт-рядків:
* bytes - незмінний тип, що використовують для представлення байтів.
* bytearray - змінний тип, що дозволяє модифікувати байти після їх створення.

Застосування байтових даних досить поширене. 
Наприклад байтові рядки важливі для роботи з мережевими протоколами (наприклад, TCP/IP), послідовними портами, telnet та іншими протоколами, де дані передаються як потік байтів.
За своєю суттю байт-рядки або простіше байти — це звичайні рядки, але для запису одного символу використовується суворо один байт. 
Це відрізняється від звичайних рядків, де символи (особливо в Unicode) можуть займати більше одного байта.
"""

# Для байт-рядків застосовуються ті самі обмеження і правила, що і для звичайних рядків. 
# Наприклад, ви можете використовувати методи upper(), startswith(), index(), find() і так далі.
s = b'Hello!'
print(s[1])  # Виведе: 101 (це ASCII-код символу 'e')

# Створимо наступний байт-рядок:
byte_string = b'Hello world!'
"""
В цьому прикладі у byte_string містить послідовність символів по одному байту на кожного. 
Від оголошення звичайного рядку байт-рядок вирізняє наявність символу b на початку рядка.

Другий спосіб створення байт рядків — це перетворення у байт-рядок.
Для перетворення рядка у байт-рядок можна скористатися методом рядків encode. 
Коли ви використовуєте .encode(), ви перетворюєте рядок у байтову послідовність. 
Метод .encode() важливий, оскільки він дозволяє стандартизувати рядок для операцій, які вимагають однакового представлення символів, незалежно від системи або платформи.
"""
byte_str = 'some text'.encode()
print(byte_str)

# Синтаксис:
str.encode(encoding="utf-8", errors="strict")
"""
* encoding - вказує метод кодування. По замовчуванню використовується 'utf-8', який підтримує велику кількість символів з різних мов.
* errors - вказує, як обробляти помилки кодування. Наприклад, 
    - 'strict' для викидання виключення у випадку помилки, 
    - 'ignore' для ігнорування помилок або 
    - 'replace' для заміни неможливих для кодування символів на певний замінник (?).

Ви повинні зрозуміти, що метод .encode() є фундаментальним для роботи з текстовими даними в Python, 
оскільки він забезпечує зв'язок (місток) між текстом (рядками Unicode) та байтами, які можуть бути використані в бінарних операціях або в передачі даних по мережі.
"""

""" ------------------------------------------ """
    # Перетворення чисел у байт-рядки
""" ----------------------------------------- """
"""
У Python ви можете перетворювати числа у байт-рядки за допомогою вбудованої функції bytes. 
Це корисно для роботи з двійковими даними, особливо коли потрібно зберігати або передавати числові значення у форматі, оптимізованому для обробки на низькому рівні.
В один байт поміщається число від 0 до 255 включно, відповідно можна перетворити послідовність чисел від 0 до 255 у байт-рядок за допомогою функції bytes:
"""
# Перетворення списку чисел у байт-рядок
numbers = [0, 128, 255]
byte_numbers = bytes(numbers)
print(byte_numbers)  # Виведе байтове представлення чисел

# Щоб перевірити правильність представлення, можна скористатися вбудованою функцією hex, яка перетворить ціле число в рядок — представлення числа в шістнадцятковій формі:
for num in [127, 255, 156]:
  print(hex(num))

""" ------------------------------------------ """
    # Кодування рядків (ASCII, UTF-8, CP1251)
""" ----------------------------------------- """
"""
Перші комп'ютери для роботи з текстом використовували так зване ASCII кодування. 
У цьому кодуванні для запису одного символу використовується один байт.
Зручність цього кодування в тому, що будь-які дані на комп'ютері можна спробувати представити у вигляді тексту в цьому кодуванні. 
ASCII містить 256 символів. Це не дуже багато і деякий час цього було достатньо. 
Але з часом алфавіту з 256 символів стало мало, виникла необхідність додати все більше символів (кирилиця, діакритичні знаки, коди валют, ієрогліфи тощо). 
Щоб задовольнити потребу у додаванні нових символів, придумали використати кодування, де більше одного байту на символ. 
Python за замовчуванням використовує UTF-8, в якій один символ може займати від 1 до 4 байт, і всього в алфавіті може бути до 1 112 064 знаків. 
Це не єдине кодування, на різних платформах можуть бути присутні власні, наприклад CP-1251 (кирилиця на ОС сімейства Windows), UTF-16, UTF-32 та інші.
"""
# Щоб дізнатися, якому елементу в UTF-8 відповідає символ, є функція ord (від order).
ord('a')  # 97

# Зворотна операція, коли потрібно дізнатися, який символ закодований числом, наприклад 100, є функція chr (скорочено від character):
chr(100)  # 'd'

# Python може працювати з дуже великою кількістю різних кодувань.
s = "Привіт!"

utf8 = s.encode()
print(f"UTF-8: {utf8}")

utf16 = s.encode("utf-16")
print(f"UTF-16: {utf16}")

cp1251 = s.encode("cp1251")
print(f"CP-1251: {cp1251}")

s_from_utf16 = utf16.decode("utf-16")
print(s_from_utf16 == s)

# Спроба перетворити байт-рядок в неправильному кодуванні, призводить або до помилки, або до досить непередбачуваного результату:
print(b'Hello world!'.decode('utf-16'))

"""
Коли файл зберігається в кодуванні, відмінному від UTF-8, і потім відкривається у програмі, яка очікує UTF-8 (або навпаки), це може призвести до неправильного відображення тексту. 
Символи, які не відповідають стандарту кодування, можуть відображатися як нерозпізнані знаки або викликати помилки при читанні файлу.

Щоб уникнути проблем з кодуванням, особливо при роботі з міжнародними текстами або в середовищах з різними налаштуваннями кодування, рекомендується завжди явно вказувати кодування UTF-8 під час відкриття файлів у Python. 
Це можна зробити за допомогою параметра encoding у функції open().
"""
# Відкриття текстового файлу з явним вказівкам UTF-8 кодування
with open('example.txt', 'r', encoding='utf-8') as file:
    content = file.read()
    print(content)
# У цьому прикладі, навіть якщо операційна система використовує інше кодування за замовчуванням, файл буде коректно відкритий із використанням UTF-8, що гарантує правильне відображення тексту.

""" ------------------------------------------ """
    # Масив байтів
""" ----------------------------------------- """
"""
Робота з рядками обмежена тим, що рядки і байт-рядки незмінні. 
Якщо потрібно замінити навіть один символ, потрібно, по суті, створити копію початкового рядка з єдиним відмінним символом. 
Щоб зменшити накладні витрати при роботі з "сирими" даними, в Python є такий контейнер як bytearray.
"""
byte_array = bytearray(b'Kill Bill')
byte_array[0] = ord('B')
byte_array[5] = ord('K')
print(byte_array) # bytearray(b'Bill Kill')

"""
Основна відмінність від байт-рядків — це змінність, щоб змінити масив байтів, не потрібно створювати новий. 
Друга важлива відмінність — це те, що масив байтів сприймається системою як послідовність чисел від 0 до 255, а не як послідовність символів в ASCII кодуванні. 
Саме тому не можна написати byte_array[0] = b'B'. Елементи масиву байтів сприймаються саме як цілі числа.
"""
# Окрім зміни існуючих елементів, bytearray дозволяє додавати та видаляти елементи, що робить його набагато більш гнучким у порівнянні з незмінними байт-рядками.
byte_array = bytearray(b"Hello")
byte_array.append(ord("!"))  
print(byte_array) # bytearray(b'Hello!')

# Хоча bytearray сприймається як послідовність чисел, його можна легко перетворити в рядок за допомогою методу decode(), вказавши потрібне кодування.
byte_array = bytearray(b"Hello World")
string = byte_array.decode("utf-8")
print(string)  # Виведе: 'Hello World'

""" ------------------------------------------ """
    # Порівняння рядків
""" ----------------------------------------- """
"""
Принцип порівняння рядків, з перетворенням їх у єдиний регістр, використовується для забезпечення нерозрізнення регістру при порівнянні. 
Це особливо корисно, коли порівняння повинно бути незалежним від того, чи введено рядок у верхньому, нижньому чи змішаному регістрі.

Основні кроки процесу порівняння наступні:
Перше, це перетворення рядків у єдиний регістр. 
Це може бути або перетворення всіх символів рядка у нижній регістр за допомогою методу .lower(), або у верхній регістр за допомогою .upper().

Далі сама операція порівняння рядків. 
Після перетворення обох рядків у однаковий регістр, вони порівнюються. 

Якщо рядки однакові після перетворення, вони вважаються еквівалентними у контексті нерозрізнення регістру.
"""
string1 = "Hello World"
string2 = "hello world"
if string1.lower() == string2.lower():
    print("Рядки однакові")
else:
    print("Рядки різні")

"""
Але порівняння рядків у Python може давати неоднозначний результат внаслідок того, що в UTF-8 кодуванні один і той самий символ можна представити декількома кодами,
наприклад, символ 'ê' можна представити кодом U+00EA, або як послідовність двох кодів U+0065 та U+0302. 
З цієї причини порівняння одного і того самого символу може повернути False через відмінності у записі.

Щоб розв'язати цю проблему при роботі з не ASCII символами для порівняння рядків, їх необхідно нормалізувати за допомогою методу casefold, 
який повертає рядок, де всі символи у нижньому регістрі і без неоднозначностей, коли будь-який символ матиме тільки одну можливу форму запису.

Цей метод схожий на lower(), але casefold() є більш радикальним: 
він призначений для видалення усіх відмінностей у регістрі, які можуть виникати в різних мовах, 
і тому є більш ефективним для випадків, де потрібно забезпечити нерозрізнення регістру в різноманітних мовах.
"""
text = "Python Programming"
print(text.casefold())

"""
Виведення буде 'python programming' таке саме як і для методу .lower().

Але головне застосування casefold() для мов, де одна літера може мати різні верхній та нижній регістри, наприклад, в німецькій мові.
У німецькій мові, літера "ß" (так званий "sharp S" або "eszett") використовується для позначення специфічного звука, що наближений до подвоєного "ss". 
Ця літера не має прямого еквіваленту у верхньому регістрі. Традиційно, коли слово, що містить "ß", потрібно написати великими літерами, "ß" перетворюється на "SS".

Ось тут casefold() виявляється корисним:
"""
german_word = 'straße'  # В нижньому регістрі
search_word = 'STRASSE'  # В верхньому регістрі

# Порівняння за допомогою lower()
lower_comparison = german_word.lower() == search_word.lower()

# Порівняння за допомогою casefold()
casefold_comparison = german_word.casefold() == search_word.casefold()

print(f"Порівняння з lower(): {lower_comparison}")
print(f"Порівняння з casefold(): {casefold_comparison}")




