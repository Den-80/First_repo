# 1.Правило перше - число 0 приводиться до False (ціле, дійсне або комплексне). 
money = 0
if money:
    print(f"You have {money} on your bank account")
else:
    print("You have no money and no debts")

# 2.Правило друге - значення None приводиться до False.
result = None
if result:
    print(result)
else:
    print("Result is None, do something")

# 3.Правило третє - порожній контейнер, порожній рядок тощо, приводиться до False. 
user_name = input("Enter your name: ")

if user_name:
    print(f"Hello {user_name}")
else:
    print("Hi Anonym!")

# 4.Правило останнє - все інше приводиться до True
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
# Оператор is
# Оператор is у Python використовується для перевірки того, чи два об'єкти вказують на одну і ту ж область пам'яті, тобто чи вони є одним і тим же об'єктом.
a = [1, 2, 3]
b = a
c = [1, 2, 3]

print(a is b)  # True
print(a is c)  # False

# Однак основне його застосування - це перевірка, чи змінна є None.
# if my_var is None:
    # Робимо щось, якщо 'my_var' є 'None'

""" 
Основні операції в булевій алгебрі включають:

AND (і): Операція повертає True, якщо обидва операнди є True. Наприклад, True AND True є True, в той час як True AND False є False.
OR (або): Операція повертає True, якщо хоча б один з операндів є True. Наприклад, True OR False є True.
NOT (ні): Унарна операція, яка інвертує значення; True стає False, а False стає True.
"""
# Задаємо конкретне число
num = int(input())

# Перевіряємо кратність
if num % 3 == 0 and num % 5 == 0:
    print("FizzBuzz")
elif num % 3 == 0:
    print("Fizz")
elif num % 5 == 0:
    print("Buzz")
else:
    print(num)

"""
Тернарні операції

Тернарні оператори в Python є елегантним способом вираження умовних виразів у скороченій формі. 
Вони дозволяють вам вибирати між двома значеннями залежно від того, чи є певна умова істинною або неправдивою. 
Це робить код компактнішим і часто полегшує його читання.
"""
is_nice = True
state = "nice" if is_nice else "not nice"

"""
Оператор match

Оператор match, введений у Python починаючи з версії 3.10, 
є схожим на оператори switch-case в інших мовах програмування. 
Він дозволяє порівнювати значення з декількома шаблонами і виконувати різні блоки коду 
в залежності від того, який шаблон відповідає значенню.
"""
fruit = "apple"

match fruit:
    case "apple":
        print("This is an apple.")
    case "banana":
        print("This is a banana.")
    case "orange":
        print("This is an orange.")
    case _:
        print("Unknown fruit.")
# Символ _ тут використовується як "заглушка" для вказівки на будь-які інші випадки, 
# які не відповідають переліченим. 
# У цьому випадку на екран виведеться "Unknown fruit.".


pets = ["dog", "fish", "cat"]

match pets:
    case ["dog", "cat", _]:
        # Випадок, коли є і собака, і кіт
        print("There's a dog and a cat.")
    case ["dog", _, _]:
        # Випадок, коли є тільки собака
        print("There's a dog.")
    case _:
        # Випадок для інших комбінацій
        print("No dogs.")
"""========================================================================================================="""       
"""
Цикли

Для того, щоб повторити якийсь блок коду кілька разів або повторювати, 
доки виконується деяка умова, у Python реалізовані цикли. 
Вони є фундаментальною конструкцією, яка дозволяє повторювати виконання певного блоку коду кілька разів.

Існують два основних типи циклів: for та while.:

Цикл for в Python використовується для ітерації по елементах будь-якої послідовності 
(наприклад, списку, кортежу, рядка) або інших ітерованих об'єктів;

for element in sequence:
    # виконувати дії з element

Цикл while виконує блок коду, поки задана умова є істинною (True). 
Як тільки умова стає неправдивою (False), цикл закінчується.

while condition:
    # виконувати дії, поки condition є True
"""
alphabet = "abcdefghijklmnopqrstuvwxyz"
for char in alphabet:
    print(char, end=" ")

k = 0
while k < 10:
    k = k + 1
    print(k)

"""
«Нескінченні цикли» та break

Бувають ситуації, коли необхідно вийти з циклу до завершення ітерації, не дочекавшись, 
доки станеться чергова перевірка умови. Для цього є команда break. 
Команда break зупиняє цикл в момент виклику і не завершує ітерацію.

Нескінченні цикли часто застосовуються там, де потрібно взаємодіяти з клієнтом, 
чекаючи введення від нього, і завершується тільки при настанні деякої умови.
"""
a = 0
while True:
    print(a)
    if a >= 20:
        break
    a = a + 1
    
"""
Наприклад echo скрипт, який виводить в консоль те, що ви введете, 
доки ви не введете рядок тексту exit:
"""
while True:
    user_input = input()
    print(user_input)
    if user_input == "exit":
        break

"""
Завершення ітерації за допомогою continue

Також для того, аби одразу перейти до наступної ітерації циклу 
без виконання виразів, що залишилися, є команда continue. 

Виклик цієї команди у тілі циклу призводить до того, що вирази цієї ітерації, що залишилися, 
не будуть виконані, а інтерпретатор одразу перейде до наступної ітерації або перевірки умови.
"""
a = 0
while a < 6:
    a = a + 1
    if not a % 2:
        continue
    print(a)

#Оператори continue та break працюють тільки всередині одного циклу. 
#В ситуації вкладених циклів немає способу вийти з усіх циклів одразу.
while True:
    number = input("number = ")
    number = int(number)
    while True:
        print(number)
        number = number - 1
        if number < 0:
            break

"""
 Також використання continue або break поза циклом призводить до синтаксичної помилки.
"""
number = int(input("number = "))
if number < 0:
    break
#Такий код призводить до помилки SyntaxError. Такі помилки називаються винятками.
"""==================================================================================="""
""" Розширення можливостей циклу for """
"""
Зараз ми розглянемо три ключові функції Python, які забезпечують потужні 
і гнучкі способи для ітерації, або повторення певних дій: range, enumerate та zip.

1. Функція range важлива для створення послідовностей чисел, які ви можете використовувати у циклах. 
Вона надзвичайно корисна, коли вам потрібно виконати дію певну кількість разів або ітерувати через послідовність чисел.
2. Коли вам потрібно отримати доступ не тільки до значення з ітерованої колекції, але до її індексу,
тут функція enumerate стає незамінним помічником. 
Ця функція дозволяє вам легко отримувати доступ до індексу кожного елементу під час ітерації.
3. Функція zip використовується для одночасної ітерації по кількох колекціях. 
Якщо вам потрібно комбінувати дані з різних джерел, або виконувати операції, 
які залежать від декількох пов'язаних колекцій, zip дозволяє це зробити легко та елегантно.
"""

"""
1. Функція range створює послідовність чисел. Вона може бути використана різними способами:
range(stop): Створює послідовність чисел від 0 до stop - 1.
range(start, stop): Генерує числа від start до stop - 1.
range(start, stop, step): Створює числа від start до stop - 1, з кроком step.
"""
for i in range(5):
    print(i)

for i in range(2, 10):
    print(i)

for i in range(0, 10, 2):
    print(i)

"""
2. Функція enumerate використовується для одночасного отримання індексу та значення елементів ітерованого об'єкта. 
Це корисно, коли вам потрібно отримати доступ до індексу елементів під час ітерації.
"""
some_list = ["apple", "banana", "cherry"]
for index, value in enumerate(some_list):
    print(index, value)

"""
3. Функція zip використовується для ітерації по декількох ітерованих об'єктах одночасно. 
Вона "застібає" елементи з кожного ітерованого об'єкта, створюючи кортежі з цих елементів.
"""
list1 = ["зелене", "стигла", "червоний"]
list2 = ["яблуко", "вишня", "томат"]
for number, letter in zip(list1, list2):
    print(number, letter)

"""
Коли колекції, передані в zip, мають різну довжину, zip обробляє елементи до тих пір, 
поки не закінчаться елементи в найкоротшій колекції. 
Це означає, що ітерація припиняється, як тільки буде досягнутий кінець однієї з колекцій, 
і будь-які додаткові елементи в інших, більш довгих колекціях, ігноруються.
"""
list1 = [1, 2, 3]
list2 = ['a', 'b', 'c', 'd', 'e']

for number, letter in zip(list1, list2):
    print(number, letter)

""" =================================================================================== """
""" Цикли та словники """
"""
Ітерування за словником — це такий блок коду, 
який дуже часто зустрічається при програмуванні, тож корисно вміти це робити.

Спершу варто сказати, що словник сам по собі — це ітерований контейнер 
і за ним можна ітеруватися в циклі for без необхідності заводити якийсь зовнішній лічильник тощо. 
Створимо словник, в якому ключами будуть числа, а значеннями — числівники англійською:
"""
numbers = {
    1: "one",
    2: "two",
    3: "three"
}
#Тепер давайте просто пройдемо словником в циклі та виведемо, що нам повертає ітератор на кожній ітерації:
for key in numbers:
    print(key)

#Ітеруючи за словником, ви перебираєте ключі словника. 
#Таку саму поведінку можна отримати, використовуючи метод keys, але так ви явно вкажете, що хочете перебрати ключі:
for key in numbers.keys():
    print(key)

#Часто необхідно перебрати саме значення словника, для цього скористаємося методом values:
for val in numbers.values():
    print(val)

#Щоб перебрати пари ключ значення словника треба використати метод items. На кожній ітерації ми отримаємо пару (ключ, значення):
for key, value in numbers.items():
    print(key, value)

"""
Важливо пам'ятати, що не можна робити, поки ітеруєтеся за словником: 
не можна видаляти елементи із словника, 
не можна додавати елементи у словник. 
Але можна перезаписувати значення, якщо ви ітеруєтеся за ключами. 

Теж саме стосуються і списку - 
не можна видаляти елементи списку та 
не можна додавати елементи у список під час ітерацій в циклі.
"""
""" ========================================================================================================== """

""" Механізм обробки винятків """
"""
Для обробки винятків існує оператор try ... except .... 
Синтаксично цей оператор розпочинається з ключового слова try: (спробувати) та продовжується блоком коду, 
в якому ми чекаємо, що може статися помилка.

Далі йде блок обробки винятків except (крім), де можна вказати один або більше винятків. 
Якщо один із зазначених винятків станеться, то виконається наступний блок коду.
Якщо помилки можуть бути різні і обробляти їх потрібно теж по-різному, то можна додати декілька блоків except, 
у кожному вказати свою помилку і що робити, якщо вона станеться.

Потім іде необов'язковий блок, який розпочинається з ключового слова else. 
Цей код виконається, тільки якщо винятків не сталося.

Останнім іде необов'язковий блок коду, який розпочинається з ключового слова finally, 
він виконається у будь-якому разі, незалежно від того, були помилки або ні.
"""
val = 'a'
try:
    val = int(val)
except ValueError:
    print(f"val {val} is not a number")
else:
    print(val > 0)
finally:
    print("This will be printed anyway")

"""
Винятки у Python — це дуже потужний інструмент, який часто використовується для управління потоком виконання, 
а не тільки для обробки помилок. У динамічних мовах ніколи не можна бути на 100% впевненим у тому, 
що користувач увів значення коректного типу, або що інший застосунок не повернув None замість int, наприклад.

Наївним розв'язанням цієї проблеми буде повсюдне використання перевірок if на коректність введеного користувачем 
або іншим застосунком значення. 
Просунутішим, зручнішим і прозорішим рішенням є використання механізму обробки винятків там, 
де вони можуть статися через некоректні вхідні дані.
"""
age = input("How old are you? ")
try:
    age = int(age)
    if age >= 18:
        print("You are adult.")
    else:
        print("You are infant")
except ValueError:
    print(f"{age} is not a number")
