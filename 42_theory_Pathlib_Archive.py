""" ***************************************** """
    # Робота з архівами та модуль Pathlib #
""" ***************************************** """

""" ------------------- """
    # Робота з архівами
""" ------------------- """
"""
Архіви по своїй суті — це ті самі файли, але інформація в них розташована з використанням алгоритмів стискання, 
які дозволяють записати інформацію в меншому об'ємі.
Ви можете відкрити будь-який архів як файл в режимі роботи з байт-рядками, реалізувати алгоритм стискання і розпаковування на Python, 
і отримати власний архіватор/деархіватор. 
Ця досить цікава вправа і ви, звичайно, можете її виконати, якщо хочете глибше розібратися в алгоритмах стискання.
"""
# ☝ Модуль shutil в Python 
"""- це модуль стандартної бібліотеки, який надає ряд функцій для роботи з файлами і колекціями файлів. 
Цей модуль може бути використаний для копіювання, переміщення, перейменування та видалення файлів і директорій, 
забезпечуючи високорівневі операції для обробки файлової системи, які є більш зручними, ніж використання базових функцій модуля os.

Пакет shutil підтримує архіви zip, tar, gz. Для цього він використовує пакети zipfile та tarfile. 
Ви можете використовувати їх напряму, якщо захочете.
"""

# Функція shutil.make_archive() 
#  в Python використовується для створення архівів (наприклад, ZIP або TAR файлів) з заданої директорії.
shutil.make_archive(base_name, format, root_dir=None, base_dir=None)
"""
Параметри:
* base_name - шлях до файлу, де потрібно зберегти архів, без розширення.
* format - формат архіву, наприклад 'zip', 'tar', 'gztar', 'bztar' або 'xztar'.
* root_dir - директорія, з якої буде створено архів. Якщо не вказано, використовується поточна директорія.
* base_dir - директорія всередині архіву, з якої почнеться архівація.
"""

# Створення ZIP-архіву з вмістом директорії 'my_folder'
import shutil
shutil.make_archive('example', 'zip', root_dir='my_folder')
"""
Цей код створить zip архів з ім'ям example.zip, що містить усі файли та піддиректорії, що знаходяться у директорії my_folder.
"""

# Створення TAR.GZ архіву
import shutil
shutil.make_archive('example', 'gztar', root_dir='my_folder')

# Функція shutil.unpack_archive() використовується для розпакування архівних файлів, таких як ZIP або TAR, до вказаної директорії. 
shutil.unpack_archive(filename, extract_dir=None, format=None)
"""
Параметри:
* filename - шлях до архівного файлу, який потрібно розпакувати.
* extract_dir - директорія, куди буде розпаковано вміст архіву. Якщо не вказано, використовується поточна директорія.
* format - формат архіву наприклад, zip, tar, gztar, bztar, або xztar. Якщо параметр не вказано, Python намагається визначити формат автоматично.
"""
# Розпакування zip архіву:
import shutil
shutil.unpack_archive('example.zip', 'destination_folder')

"""
Окрім роботи з архівами модуль shutil може ще виконувати наступні високорівневі операції для обробки файлової системи:
* shutil.copy(src, dst) копіює файл з src в dst. Якщо dst є директорією, файл буде скопійований зі своїм поточним іменем у цю директорію.
* shutil.copytree(src, dst) рекурсивно копіює всю директорію src в директорію dst.
* shutil.move(src, dst) переміщує файл або директорію src в dst.
* shutil.rmtree(path) рекурсивно видаляє директорію path.
* shutil.disk_usage(path) повертає статистику використання диска, що містить загальний об'єм, використаний об'єм і вільний об'єм для даного шляху.
"""
# Наведемо приклад використання shutil для копіювання файлу та директорії:
import shutil

# Копіюємо файл
source_file = '/path/to/source/file.txt'
destination_dir = '/path/to/destination'
shutil.copy(source_file, destination_dir)

# Копіюємо всю директорію
source_dir = '/path/to/source/directory'
destination_dir = '/path/to/destination/directory'
shutil.copytree(source_dir, destination_dir)


""" ------------------- """
    # Основи модуля pathlib
""" ------------------- """
"""
Модуль pathlib в Python є сучасним інструментом для роботи з файловою системою, що надає об'єктно-орієнтований інтерфейс для роботи з шляхами. 
Він прийшов на заміну застарілому модулю os, роботу з яким ще можна зустріти в старих прикладах коду.

pathlib - це модуль у Python, який надає класи для обробки файлових шляхів у об'єктно-орієнтованому стилі. 
Два основних класи у цьому модулі - це Path та PurePath.
"""

# PurePath - це базовий клас у pathlib, який надає об'єктно-орієнтовані методи для маніпуляції шляхами без доступу до файлової системи. 
"""
Він може бути використаний для роботи з шляхами на різних операційних системах. 
PurePath дозволяє виконувати такі операції, як розділення шляху на частини, перевірка суфіксів, імен файлів, шляхів тощо.
"""
from pathlib import PurePath

p = PurePath("/usr/bin/simple.jpg")
print("Name:", p.name)      # Name: simple.jpg
print("Suffix:", p.suffix)  # Suffix: .jpg
print("Parent:", p.parent)  # Parent: \usr\bin
"""
У PurePath є ряд корисних методів та атрибутів:
* p.parent вказує на батьківську директорію;
* p.name повертає лише рядок з ім'ям директорі або файлу, на який вказує p;
* p.suffix повертає рядком розширення файлу, на який вказує p, починаючи з крапки;
"""

# Клас Path
"""
наслідує всі методи з PurePath і додає методи для виконання операцій, які вимагають доступу до файлової системи:
- читання, 
- запис файлів, 
- перевірка існування файлів тощо. 
З класом Path можна створювати нові файли, читати та записувати дані, перевіряти існування шляхів, перелічувати файли у директорії тощо.

В основному робота з файловою системою ведеться через Path. 
Path варто сприймати як вказівку на файл або директорію. 
Щоб створити такий Path, достатньо викликати Path як функцію та передати у якості аргументу рядок-адресу у файловій системі:
"""
from pathlib import Path

p = Path("example.txt")
p.write_text("Hello, world!")
print(p.read_text()) 
print("Exists:", p.exists()) 

"""
У даному фрагменті коду використовується модуль pathlib для створення, запису, читання та перевірки файлу. 
Спочатку створюється об'єкт Path, який вказує на файл example.txt у директорії де був запущений скрипт. 
За допомогою методу write_text(), у цей файл записується рядок "Hello, world!". 
Потім за допомогою методу read_text() вміст файлу читається і виводиться на екран. 
На завершення, метод exists() використовується для перевірки існування файлу, результат чого також виводиться на екран. 
Весь код демонструє просту інтеракцію з файловою системою через об'єктно-орієнтований інтерфейс pathlib.

Застосування Path і PurePath залежить від конкретних потреб програми. 
Для більшості практичних цілей Path буде найкращим вибором, оскільки він надає більш широкий спектр можливостей для роботи з файлами та директоріями.
"""

""" ------------------- """
    # Створення Шляхів
""" ------------------- """
"""
Створення шляхів за допомогою класу Path у модулі pathlib у Python є зручним способом маніпуляції файловими шляхами, 
який абстрагує від особливостей конкретної операційної системи.

Клас Path автоматично адаптується до особливостей шляхів у різних операційних системах. 
Наприклад, у Windows використовуються зворотні слеші (\), тоді як в Unix-подібних системах (Linux, macOS) - прямі слеші (/).
"""
# Сам приклад процесу створення шляху наступний:
from pathlib import Path

# Для Unix/Linux
path_unix = Path("/usr/bin/python3")

# Для Windows
path_windows = Path("C:/Users/Username/Documents/file.txt")

"""
Об'єднання шляхів у pathlib - це процес, за допомогою якого можна створювати повні шляхи до файлів або директорій шляхом додавання різних частин шляху разом.
Для об'єднання шляхів використовується оператор /. 
Це інтуїтивний спосіб створення шляху, який абстрагується від різниці в синтаксисі шляхів між різними операційними системами.
"""
from pathlib import Path

# Початковий шлях
base_path = Path("/usr/bin")

# Додавання додаткових частин до шляху
full_path = base_path / "subdir" / "script.py"

print(full_path)  # Виведе: /usr/bin/subdir/script.py

# З pathlib, ви можете легко перетворювати шляхи між абсолютними та відносними форматами.
# Перетворення відносного шляху в абсолютний
from pathlib import Path
relative_path = Path("test.txt")
absolute_path = relative_path.absolute()
print(absolute_path)

# Існує метод relative_to() який навпаки, використовується для отримання відносного шляху відносно заданої директорії.
# Перетворення відносного шляху в абсолютний
from pathlib import Path
relative_path = Path("./test.txt")
absolute_path = relative_path.absolute()

current_working_directory = Path("/Users/denis/Documents")
relative_path = absolute_path.relative_to(current_working_directory)
print(relative_path)

""" ------------------- """
    # Маніпуляція з компонентами шляху
""" ------------------- """
"""
Клас Path надає зручні методи для маніпулювання компонентами шляху, такі як with_name і with_suffix. 
Ці методи дозволяють легко змінювати ім'я файлу або його розширення в об'єкті Path.
"""
# Метод with_name замінює ім'я файлу в шляху на нове.
""" Він корисний, коли вам потрібно змінити тільки ім'я файлу, зберігаючи решту шляху незмінною.
У цьому прикладі, with_name("report.txt") замінює ім'я файлу example.txt на report.txt, при цьому зберігаючи решту шляху documents без змін."""

from pathlib import Path
# Початковий шлях до файлу
original_path = Path("documents/example.txt")
# Зміна імені файлу
new_path = original_path.with_name("report.txt")
print(new_path)

# Метод with_suffix
"""замінює або додає розширення файлу в шляху. 
Це корисно, коли потрібно змінити тип файлу або додати розширення до файлу, який його не має. """
from pathlib import Path
# Початковий шлях до файлу
original_path = Path("documents/example.txt")
# Зміна імені файлу
new_path = original_path.with_suffix(".md")
print(new_path)

"""
Але треба розуміти, що методи with_name і with_suffix в класі Path модуля pathlib в Python не змінюють фізичне ім'я файлу на диску. 
Замість цього, вони використовуються для створення нового об'єкта Path, який відображає змінений шлях.
"""
from pathlib import Path
original_path = Path("documents/example.txt")
# Створює новий об'єкт Path з іншим ім'ям файлу
new_path = original_path.with_name("report.txt")
print(original_path)
print(new_path)

"""
Щоб фізично змінити ім'я файлу на диску, потрібно використовувати методи для роботи з файловою системою, наприклад, rename. 
Цей виклик змінить ім'я файлу example.txt на report.txt у директорії documents на диску.
"""
from pathlib import Path
original_path = Path("documents/example.txt")
# Створює новий об'єкт Path з іншим ім'ям файлу
new_path = original_path.with_name("report.txt")
original_path.rename(new_path)


""" ------------------------- """
    # Читання та запис файлів
""" ------------------------- """
"""
Модуль pathlib надає кілька методів для читання з файлів та запису в них, 
що зменшує необхідність використання стандартного модуля open. 
Але вони не замінюють його, а є доповненням.

Методи read_text() та write_text() використовуються для читання та запису текстових файлів.
"""
# Синтаксис методу read_text()
Path.read_text(encoding=None, errors=None)
"""
Параметри:
* encoding - необов'язковий, ім'я кодування, яке використовується для декодування файлу. Якщо не вказано, використовується кодування за замовчуванням.
* errors - необов'язково, інструкція, як обробляти помилки декодування.
"""

# Синтаксис методу write_text()
Path.write_text(data, encoding=None, errors=None)
"""
* data - рядок, який необхідно записати в файл.
* encoding - необов'язковий, ім'я кодування, яке використовується для декодування файлу. Якщо не вказано, використовується кодування за замовчуванням.
* errors - необов'язково, інструкція, як обробляти помилки декодування.

Як бачимо параметр errors, в обох методах, визначає, як мають бути оброблені ці помилки.
errors='strict'. Це значення за замовчуванням. Якщо виникає помилка декодування, буде викинуто виключення UnicodeDecodeError.
errors='ignore'. Якщо ми хочемо ігнорувати помилки декодування. Частини тексту, що не можуть бути декодовані, будуть просто пропущені.
errors='replace'. Якщо пропускати ми не хочемо, то замінимо неможливі для декодування символи на спеціальний символ заміни, згідно документації символ '?'.
"""
# Приклад запису тексту у файл:
from pathlib import Path
# Створення об'єкту Path для файлу
file_path = Path("example.txt")
# Запис тексту у файл
file_path.write_text("Привіт світ!", encoding="utf-8")

# Приклад читання тексту з файлу:
from pathlib import Path
# Створення об'єкту Path для файлу
file_path = Path("example.txt")
# Читання тексту з файлу
text = file_path.read_text(encoding="utf-8")
print(text)

# Методи read_bytes() та write_bytes() використовуються для читання та запису бінарних файлів.
# Приклад запису бінарних даних у файл

from pathlib import Path
# Створення об'єкту Path для бінарного файлу
file_path = Path("example.bin")
# Бінарні дані для запису
data = b"Python is great!"
# Запис байтів у файл
file_path.write_bytes(data)

# Приклад читання бінарних даних з файлу

from pathlib import Path
# Створення об'єкту Path для бінарного файлу
file_path = Path("example.bin")
# Читання байтів з файлу
binary_data = file_path.read_bytes()
print(binary_data)


""" ------------------------- """
    # Роботу з директоріями
""" ------------------------- """
"""
Модуль pathlib в Python включає функціонал для ефективної роботи з файловою системою, зокрема з директоріями.
"""
# Метод iterdir() 
"""використовується для отримання переліку всіх файлів та піддиректорій у вказаній директорії. 
Цей метод повертає ітератор, який виробляє об'єкти Path для кожного файлу та піддиректорії у директорії, 
що визначена поточним об'єктом Path."""

from pathlib import Path
# Створення об'єкту Path для директорії
directory = Path("./.idea")
# Виведення переліку всіх файлів та піддиректорій
for path in directory.iterdir():
    print(path)

# Для створення нової директорії використовується метод mkdir().
Path.mkdir(mode=0o777, parents=False, exist_ok=False)
"""
Параметри:
* mode - права доступу до директорії, використовуються для Linux і не актуальні для Windows.
* parents - якщо має значення True, створить всі батьківські директорії, які відсутні.
* exist_ok - якщо має значення True, помилка не буде викинута, якщо директорія вже існує.
"""

from pathlib import Path
directory = Path('./test_directory/new_folder')
directory.mkdir(parents=True, exist_ok=True)

# Для видалення директорії використовується метод rmdir(). 
# Він видаляє директорію, але директорія повинна бути порожньою.
from pathlib import Path
directory = Path('./test_directory/new_folder')
directory.rmdir()

"""
Модуль pathlib також надає декілька методів для перевірки існування та типу файлових об'єктів:

* метод exists() перевіряє, чи існує файл або директорія.
* метод is_dir() перевіряє, чи є об'єкт директорією.
* метод is_file() перевіряє, чи є об'єкт файлом.
"""
from pathlib import Path

path = Path("./test_directory")

# Перевірка існування
if path.exists():
    print(f"{path} існує")

# Перевірка, чи це директорія
if path.is_dir():
    print(f"{path} є директорією")

# Перевірка, чи це файл
if path.is_file():
    print(f"{path} є файлом")

""" ------------------------- """
    # Переміщення та копіювання файлів
""" ------------------------- """
"""
Модуль pathlib чудово інтегрується з модулем shutil для виконання операцій копіювання та переміщення файлів. 
Для копіювання файлів використовується функція shutil.copy() або shutil.copy2().
"""
import shutil
from pathlib import Path
# Вихідний і цільовий файли
source = Path('/path/to/source/file.txt')
destination = Path('/path/to/destination/file.txt')
# Копіювання файла
shutil.copy(source, destination)

# Функція shutil.copy() копіює вміст файлу, але не копіює метадані, тоді як shutil.copy2() копіює і вміст, і метадані.

# функція shutil.move() - використовується для переміщення файлів
import shutil
from pathlib import Path
# Вихідний і цільовий шляхи
source = Path('/path/to/source/file.txt')
destination = Path('/path/to/destination/file.txt')
# Переміщення файла
shutil.move(source, destination)

# Метод stat() повертає інформацію про файл, включаючи його розмір.
from pathlib import Path
file_path = Path("./example.bin")
# Отримання розміру файла
size = file_path.stat().st_size
print(f"Розмір файла: {size} байтів")

# Метод stat() також надає час створення, атрибут st_ctime, та час останньої модифікації файлу, атрибут st_mtime.
from pathlib import Path
import time
file_path = Path("./example.bin")
# Час створення та модифікації
creation_time = file_path.stat().st_ctime
modification_time = file_path.stat().st_mtime
print(f"Час створення: {time.ctime(creation_time)}")
print(f"Час модифікації: {time.ctime(modification_time)}")

# Для видалення файлу використовується метод unlink(). Він видаляє файл, на який вказує об'єкт Path.
# Синтаксис:

Path.unlink(missing_ok=False)
"""
Параметр missing_ok якщо має значення True, то виключення не буде викинуто, якщо файл не існує. 
За замовчуванням False, це означає, що буде викинуто виняток FileNotFoundError, якщо файл не існує.
"""
from pathlib import Path
# Створення об'єкту Path для файлу
file_path = Path('/path/to/file.txt')
# Перевірка, чи файл існує, перш ніж видаляти
if file_path.exists():
    file_path.unlink()
    print(f'Файл {file_path} було видалено')
else:
    print(f'Файл {file_path} не існує')
"""
У цьому прикладі, перш ніж видалити файл, ми перевіряємо, чи він існує, щоб уникнути виключення FileNotFoundError.
Можна також видалити файл без попередньої перевірки його існування, використовуючи параметр missing_ok.
"""
from pathlib import Path
file_path = Path('/path/to/file.txt')
file_path.unlink(missing_ok=True)




























